<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script type="module">
            const pyodidePromise = import("https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js")
            const mimePromise = import("https://esm.sh/mime@4.0.1/lite");

            function createIndicator(text) {
                let indicator = document.createElement("div")
                indicator.innerText = text
                indicator.classList.add('indicator')
                let currentStatus = null;
                function setStatus(newStatus) {
                    if (currentStatus !== null) {
                        indicator.classList.remove('indicator-'+currentStatus)
                    }
                    currentStatus = newStatus
                    indicator.classList.add('indicator-'+currentStatus)
                }
                document.addEventListener('DOMContentLoaded', _ => document.getElementById("indicators").firstElementChild.appendChild(indicator))
                return setStatus
            }

            let setSWIndicator = createIndicator("Starting service worker")
            setSWIndicator('loading')

            let setPyodideIndicator = createIndicator("Starting python runtime")

            let setPipIndicator = createIndicator("Installing pip packages")

            let setServerIndicator = createIndicator("Starting mock server")


            async function handleServiceWorkerRequest(event) {
                let response;

                let requestData = event.data.request

                if (event.data.self) {
                    let url = new URL(requestData.url)
                    let fileContents = window.files[url.pathname]

                    if (fileContents !== undefined) {
                        let mime = (await mimePromise).default;
                        
                        response = new Response(fileContents, {
                            status: 200,
                            headers: {
                                'Content-Type': mime.getType(url.pathname),
                            }
                        })
                    } else {
                        response = new Response(null, {status: 404});
                    }

                } else {
                    if (window.requestHandler == null) {
                        throw new Error("Couldn't handle request, because window.requestHandler is undefined.")
                    } else {
                        let requestClone = structuredClone(requestData)
                        requestClone.headers = Object.entries(requestClone.headers)
                        if (requestClone.body) {
                            requestClone.body = await requestClone.body.arrayBuffer()
                        }
                        let responseData = await window.requestHandler(requestClone)

                        let [body, options] = responseData

                        options = Object.fromEntries(options);
                        options.headers = Object.fromEntries(options.headers);

                        response = new Response(body, options)
                    }
                }
                const clonedResponse = response.clone();
                const body = await clonedResponse.blob();
                const headers = Object.fromEntries(response.headers.entries());

                const serializedResponse = {
                    body: body,
                    status: response.status,
                    statusText: response.statusText,
                    headers: headers
                };

                if (!event.data.self) {
                    window.parent.postMessage({
                        type: 'network',
                        request: event.data.request,
                        response: serializedResponse,
                    }, '*')
                }

                event.ports[0].postMessage({ id: event.data.id, response: serializedResponse });
            }

            var pgIframe;
            var pyodide;

            function onURLChange() {
                let href = pgIframe.contentDocument.location.href
                window.parent.postMessage({
                    type: "location",
                    value: href
                }, '*')
                sendDOMUpdate()
            }

            function sendDOMUpdate() {

                window.parent.postMessage({
                    type: "domdiff",
                    value: pgIframe.contentDocument.documentElement.innerHTML,
                }, '*')
            }

            const control = {'stop': false};
            let mainPromise;

            window.startclient = () => {
                setServerIndicator('done')
                window.parent.postMessage({type: "runtime-started"}, '*')

                if (!pgIframe) {
                    pgIframe = document.createElement('iframe')
                    pgIframe.src = "/"
    
                    pgIframe.addEventListener('load', () => {
                        attachErrorListeners(pgIframe.contentWindow)
                        attachLogProxy(pgIframe.contentWindow)
    
                        let domDiffDebounce;
    
                        var observer = new MutationObserver((mutationsList, observer) => {
                            if (domDiffDebounce) clearTimeout(domDiffDebounce)
    
                            domDiffDebounce = setTimeout(() => {
                                sendDOMUpdate()
                            }, 200)
                        });
    
                        observer.observe(pgIframe.contentDocument.documentElement, {
                            attributes: true,
                            childList: true,
                            subtree: true
                        });
    
                        onURLChange()
                        window.addEventListener('popstate', onURLChange);
                        
                        document.getElementById('indicators').style.opacity = 0;
                    });
                    
                    document.body.appendChild(pgIframe)
                } else {
                    pgIframe.contentDocument.location.reload()
                }
            }

            function writeFiles(basePath, files) {
                let folders = {}

                Object.entries(files).forEach(([path, contents]) => {
                    let matches = [...path.matchAll(/\//g)]

                    for (let i = 1; i < matches.length; i++) {
                        let match = matches[i]
                        let _path = path.substring(0, match.index)

                        if (!(_path in folders)) {
                            pyodide.FS.mkdir(basePath+_path);
                            folders[_path] = "";
                        }
                    }
                    pyodide.FS.writeFile(basePath+path, contents, { encoding: "utf8" });
                })
            }

            function deleteFolderRecursive(path) {
                let stats;

                try {
                    stats = pyodide.FS.stat(path);
                } catch (e) {
                    if (e.errno === 44) {
                        return;
                    } else {
                        throw e;
                    }
                }
                
                if (pyodide.FS.isDir(stats.mode)) {
                    const files = pyodide.FS.readdir(path);
                    
                    for (const file of files) {
                        if (file === '.' || file === '..') continue;

                        const curPath = path + '/' + file;
                        if (pyodide.FS.isDir(pyodide.FS.stat(curPath).mode)) {
                            deleteFolderRecursive(curPath);
                        } else {
                            pyodide.FS.unlink(curPath);
                        }
                    }
                    pyodide.FS.rmdir(path);
                } else {
                    console.error("The path provided is not a directory:", path);
                }
            }


            async function runMain() {

                if (mainPromise) {
                    control['stop'] = true
                    await mainPromise;
                    mainPromise = null;
                    control['stop'] = false
                }

                if (!pyodide) {
                    await pyodidePromise;

                    setPyodideIndicator('loading')

                    pyodide = await loadPyodide({
                        packages: ['micropip']
                    });
                    setPyodideIndicator('done')
                    pyodide.globals.set("control", control);
                }

                let setupFilesPromise = (async ()=> {
                    pyodide.FS.chdir('/home')
                    
                    deleteFolderRecursive('/home/pyodide')
                    
                    pyodide.FS.mkdir('/home/pyodide')
                    pyodide.FS.chdir('/home/pyodide')
    
                    writeFiles('.', files)
    
                })();
                
                setPipIndicator('loading')

                let installPackages = []
                let envvars = {}
                
                Object.entries(files).forEach(([path, contents]) => {

                    if (path.endsWith('requirements.txt') && contents.trim()) {
                        let packages = contents.trim().split(/\s+/)
                        installPackages = [...installPackages, ...packages.filter(name => !(name in pyodide.loadedPackages))]
                    }

                    if (path.endsWith('.env') && contents.trim()) {
                        contents.split('\n').forEach(line => {
                            if (line.startsWith('#') || !line.trim()) return 
                            const [key, value] = line.split('=').map(kv => kv.trim());
                            if (key) envvars[key] = value || '';
                        });
                    }
                })

                pyodide.globals.set('envvars', Object.entries(envvars))

                if (installPackages.length) {
                    await pyodide.runPythonAsync(`
                        import micropip
                        await micropip.install([${installPackages.map(x => '"' + x + '"').join(', ')}])
                    `)
                }

                
                await setupFilesPromise;
                
                setPipIndicator('done')
                setServerIndicator('loading')

                mainPromise = pyodide.runPythonAsync(`
                    import asyncio
                    import importlib
                    import sys
                    import os
                    from types import ModuleType

                    os.environ.update({k: v for k, v in envvars})

                    async def check_interrupt():
                        for k,v in list(sys.modules.items()):
                            if not isinstance(v, ModuleType) or not hasattr(v, '__file__') or v.__file__ is None:
                                continue
                                
                            if v.__file__.startswith('/home/'):
                                del sys.modules[k]

                        from _internal import start

                        start()
                        
                        while True:
                            await asyncio.sleep(.1)
                            if control.stop == True:
                                import js
                                js.requestHandler = None
                                return

                    await check_interrupt()
                `)

                mainPromise.catch((e) => {
                    setServerIndicator('error')
                    console.error(e);
                })
            }

            async function handleParentMessage(event) {
                
                if (window.parent !== event.source) return
                
                if (event.data.type == 'fetch-files') {
                    window.files = event.data.value;
                    runMain()
                } else if (event.data.type == 'reload') {
                    window.files = event.data.value;
                    runMain()
                } else if (event.data.type == 'full-reload') {
                    window.location.reload()
                } else if (event.data.type == 'navigate') {
                    pgIframe.src = event.data.value
                }

                navigator.serviceWorker.addEventListener('message', handleServiceWorkerRequest);

            }

			let previous = { level: null, args: null };

            function attachLogProxy(window) {

                ['clear', 'log', 'info', 'dir', 'warn', 'error', 'table'].forEach((level) => {
                    const original = window.console[level];
                    window.console[level] = (...args) => {
                        const stringifiedArgs = stringify(args);
                        if (previous.level === level && previous.args && previous.args === stringifiedArgs) {
                            parent.postMessage({ type: 'console', level, duplicate: true }, '*');
                        } else {
                            previous = { level, args: stringifiedArgs };

                            try {
                                parent.postMessage({ type: 'console', level, args }, '*');
                            } catch (err) {
                                parent.postMessage({ type: 'console', level: 'unclonable' }, '*');
                            }
                        }

                        original(...args);
                    };
                });

                const counter = new Map();
                const original_count = window.console.count;
                const original_countreset = window.console.countReset;

                const original_trace = window.console.trace;

                window.console.trace = (...args) => {
                    const stack = new Error().stack;
                    parent.postMessage({ type: 'console', level: 'trace', args, stack }, '*');
                    original_trace(...args);
                };

                function stringify(args) {
                    try {
                        return JSON.stringify(args);
                    } catch (error) {
                        return null;
                    }
                }
            }

            function attachErrorListeners(frame) {
                frame.onerror = function (msg, url, lineNo, columnNo, error) {
                    parent.postMessage({ type: 'error', value: error }, '*');
                };

                frame.addEventListener('unhandledrejection', (event) => {
                    parent.postMessage({ type: 'unhandledrejection', value: event.reason }, '*');
                });
            }

            attachLogProxy(window)
            attachErrorListeners(window)

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/_sw_v1.js').then(async () => {
                    window.addEventListener('message', handleParentMessage)
                    window.parent.postMessage({type: "fetch-files"}, '*')
                    setSWIndicator('done')
                }).catch(error => {
                    console.error('Service Worker registration failed:', error);
                    setSWIndicator('error')
                });
            } else {
                setSWIndicator('error')
            }

            window.beforeunload = async () => {
                if ('serviceWorker' in navigator) {
                    let registrations = await navigator.serviceWorker.getRegistrations();
                    
                    for (let registration of registrations) {
                        // ("Unregistered", registration);
                        registration.unregister();
                    }
                }
            };
        </script>
    </head>
    <body>
        <div id="indicators">
            <div></div>
        </div>
    </body>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
        }

        #indicators {
            position: absolute;
            inset: 0;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            line-height: 1.5;
            --indicator-color: #585858;
        }

        .indicator {
            font-family: monospace;
            color: var(--indicator-color);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .indicator::before {
            content: "";
            width: 6px;
            height: 6px;
            background-color: var(--indicator-color);
            border-radius: 50rem;
        }
        .indicator::after {
            content: "...";
            opacity: 0;
        }
        .indicator-loading::after {
            opacity: 1;
        }
        .indicator-error {
            --indicator-color: rgb(255, 111, 111);
        }
        .indicator-done {
            --indicator-color: rgb(0, 148, 0);
        }
        .indicator-loading {
            --indicator-color: rgb(255, 255, 255);
        }

        
        iframe {
            position: absolute;
            border: none;
            width: 100%;
            height: 100%;
        }
    </style>
</html>