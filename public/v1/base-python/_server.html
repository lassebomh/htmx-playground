<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            html, body {
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden;
            }
            
            iframe {
                width: 100%;
                height: 100%;
                border: none;
            }
        </style>
        <!-- <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script> -->
        <script type="module">
            const pyodidePromise = import("https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js")
            const mimePromise = import("https://esm.sh/mime@4.0.1/lite");

            async function handleServiceWorkerRequest(event) {
                let response;

                let requestData = event.data.request

                if (event.data.self) {
                    let url = new URL(requestData.url)
                    let fileContents = window.files[url.pathname]

                    if (fileContents !== undefined) {
                        let mime = (await mimePromise).default;
                        
                        response = new Response(fileContents, {
                            status: 200,
                            headers: {
                                'Content-Type': mime.getType(url.pathname),
                            }
                        })
                    } else {
                        response = new Response(null, {status: 404});
                    }

                } else {
                    if (window.requestHandler == null) {
                        throw new Error("Couldn't handle request, because window.requestHandler is undefined.")
                    } else {
                        let requestClone = structuredClone(requestData)
                        requestClone.headers = Object.entries(requestClone.headers)
                        if (requestClone.body) {
                            requestClone.body = await requestClone.body.arrayBuffer()
                        }
                        console.log(requestClone.body);

                        let responseData = await window.requestHandler(requestClone)

                        let [body, options] = responseData

                        options = Object.fromEntries(options);
                        options.headers = Object.fromEntries(options.headers);

                        response = new Response(body, options)
                    }
                }
                const clonedResponse = response.clone();
                const body = await clonedResponse.blob();
                const headers = Object.fromEntries(response.headers.entries());

                const serializedResponse = {
                    body: body,
                    status: response.status,
                    statusText: response.statusText,
                    headers: headers
                };

                if (!event.data.self) {
                    window.parent.postMessage({
                        type: 'network',
                        request: event.data.request,
                        response: serializedResponse,
                    }, '*')
                }

                event.ports[0].postMessage({ id: event.data.id, response: serializedResponse });
            }

            var pgIframe;
            var pyodide;

            function onURLChange() {
                let href = pgIframe.contentDocument.location.href
                window.parent.postMessage({
                    type: "location",
                    value: href
                }, '*')
                sendDOMUpdate()
            }

            function sendDOMUpdate() {

                window.parent.postMessage({
                    type: "domdiff",
                    value: pgIframe.contentDocument.documentElement.innerHTML,
                }, '*')
            }

            const control = {'stop': false};
            let mainPromise;

            window.startclient = () => {
                if (!pgIframe) {
                    pgIframe = document.createElement('iframe')
                    pgIframe.src = "/"
    
                    pgIframe.addEventListener('load', () => {
                        attachErrorListeners(pgIframe.contentWindow)
                        attachLogProxy(pgIframe.contentWindow)
    
                        let domDiffDebounce;
    
                        var observer = new MutationObserver((mutationsList, observer) => {
                            if (domDiffDebounce) clearTimeout(domDiffDebounce)
    
                            domDiffDebounce = setTimeout(() => {
                                sendDOMUpdate()
                            }, 200)
                        });
    
                        observer.observe(pgIframe.contentDocument.documentElement, {
                            attributes: true,
                            childList: true,
                            subtree: true
                        });
    
                        onURLChange()
                        window.addEventListener('popstate', onURLChange);
                    });
                    
                    document.body.appendChild(pgIframe)
                } else {
                    pgIframe.contentDocument.location.reload()
                }
            }

            function writeFiles(basePath, files) {
                let folders = {}

                Object.entries(files).forEach(([path, contents]) => {
                    let matches = [...path.matchAll(/\//g)]

                    for (let i = 1; i < matches.length; i++) {
                        let match = matches[i]
                        let _path = path.substring(0, match.index)

                        if (!(_path in folders)) {
                            pyodide.FS.mkdir(basePath+_path);
                            folders[_path] = "";
                        }
                    }
                    pyodide.FS.writeFile(basePath+path, contents, { encoding: "utf8" });
                })
            }

            function deleteFolderRecursive(path) {
                let stats;

                try {
                    stats = pyodide.FS.stat(path);
                } catch (e) {
                    if (e.errno === 44) {
                        return;
                    } else {
                        throw e;
                    }
                }
                
                if (pyodide.FS.isDir(stats.mode)) {
                    const files = pyodide.FS.readdir(path);
                    
                    for (const file of files) {
                        if (file === '.' || file === '..') continue;

                        const curPath = path + '/' + file;
                        if (pyodide.FS.isDir(pyodide.FS.stat(curPath).mode)) {
                            deleteFolderRecursive(curPath);
                        } else {
                            pyodide.FS.unlink(curPath);
                        }
                    }
                    pyodide.FS.rmdir(path);
                } else {
                    console.error("The path provided is not a directory:", path);
                }
            }


            async function runMain() {

                if (mainPromise) {
                    control['stop'] = true
                    await mainPromise;
                    mainPromise = null;
                    control['stop'] = false
                }

                if (!pyodide) {
                    await pyodidePromise;

                    pyodide = await loadPyodide({
                        packages: ['micropip']
                    });
                    pyodide.globals.set("control", control);
                }

                let setupFilesPromise = (async ()=> {
                    pyodide.FS.chdir('/home')
                    
                    deleteFolderRecursive('/home/pyodide')
                    
                    pyodide.FS.mkdir('/home/pyodide')
                    pyodide.FS.chdir('/home/pyodide')
    
                    writeFiles('.', files)
    
                })();
                
                let installPackages = []
                
                Object.entries(files).forEach(([path, contents]) => {

                    if (path.endsWith('/requirements.txt') && contents.trim()) {
                        let packages = contents.trim().split(/\s+/)
                        installPackages = [...installPackages, ...packages.filter(name => !(name in pyodide.loadedPackages))]
                    }
                })

                if (installPackages.length) {
                    await pyodide.runPythonAsync(`
                        import micropip
                        await micropip.install([${installPackages.map(x => '"' + x + '"').join(', ')}])
                    `)
                }


                await setupFilesPromise;


                mainPromise = pyodide.runPythonAsync(`
                    import asyncio
                    import importlib
                    import sys
                    from types import ModuleType

                    async def check_interrupt():
                        for k,v in list(sys.modules.items()):
                            if not isinstance(v, ModuleType) or not hasattr(v, '__file__') or v.__file__ is None:
                                continue
                                
                            if v.__file__.startswith('/home/'):
                                del sys.modules[k]

                        from _internal import start

                        start()
                        
                        while True:
                            await asyncio.sleep(.1)
                            if control.stop == True:
                                import js
                                js.requestHandler = None
                                return

                    await check_interrupt()
                `)

                // try {
                // let main = pyodide.pyimport('main')
                // } catch (error) {
                //     console.log('catch error');
                // }
            }

            async function handleParentMessage(event) {
                
                if (window.parent !== event.source) return
                
                if (event.data.type == 'fetch-files') {
                    window.files = event.data.value;
                    runMain()
                } else if (event.data.type == 'reload') {
                    window.files = event.data.value;
                    runMain()
                } else if (event.data.type == 'navigate') {
                    pgIframe.src = event.data.value
                }

                navigator.serviceWorker.addEventListener('message', handleServiceWorkerRequest);

            }

			let previous = { level: null, args: null };

            function attachLogProxy(window) {

                ['clear', 'log', 'info', 'dir', 'warn', 'error', 'table'].forEach((level) => {
                    const original = window.console[level];
                    window.console[level] = (...args) => {
                        const stringifiedArgs = stringify(args);
                        if (previous.level === level && previous.args && previous.args === stringifiedArgs) {
                            parent.postMessage({ type: 'console', level, duplicate: true }, '*');
                        } else {
                            previous = { level, args: stringifiedArgs };

                            try {
                                parent.postMessage({ type: 'console', level, args }, '*');
                            } catch (err) {
                                parent.postMessage({ type: 'console', level: 'unclonable' }, '*');
                            }
                        }

                        original(...args);
                    };
                });

                [
                    { method: 'group', type: 'console_group' },
                    { method: 'groupEnd', type: 'console_group_end' },
                    { method: 'groupCollapsed', type: 'console_group_collapsed' }
                ].forEach((group_type) => {
                    const original = window.console[group_type.method];
                    window.console[group_type.method] = (label) => {
                        parent.postMessage({ type: group_type.type, label }, '*');

                        original(label);
                    };
                });

                const timers = new Map();
                const original_time = window.console.time;
                const original_timelog = window.console.timeLog;
                const original_timeend = window.console.timeEnd;

                window.console.time = (label = 'default') => {
                    original_time(label);
                    timers.set(label, performance.now());
                };
                window.console.timeLog = (label = 'default') => {
                    original_timelog(label);
                    const now = performance.now();
                    if (timers.has(label)) {
                        parent.postMessage(
                            {
                                type: 'console',
                                level: 'system-log',
                                args: [`${label}: ${now - timers.get(label)}ms`]
                            },
                            '*'
                        );
                    } else {
                        parent.postMessage(
                            { type: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] },
                            '*'
                        );
                    }
                };
                window.console.timeEnd = (label = 'default') => {
                    original_timeend(label);
                    const now = performance.now();
                    if (timers.has(label)) {
                        parent.postMessage(
                            {
                                type: 'console',
                                level: 'system-log',
                                args: [`${label}: ${now - timers.get(label)}ms`]
                            },
                            '*'
                        );
                    } else {
                        parent.postMessage(
                            { type: 'console', level: 'system-warn', args: [`Timer '${label}' does not exist`] },
                            '*'
                        );
                    }
                    timers.delete(label);
                };

                const original_assert = window.console.assert;
                window.console.assert = (condition, ...args) => {
                    if (condition) {
                        const stack = new Error().stack;
                        parent.postMessage({ type: 'console', level: 'assert', args, stack }, '*');
                    }
                    original_assert(condition, ...args);
                };

                const counter = new Map();
                const original_count = window.console.count;
                const original_countreset = window.console.countReset;

                window.console.count = (label = 'default') => {
                    counter.set(label, (counter.get(label) || 0) + 1);
                    parent.postMessage(
                        { type: 'console', level: 'system-log', args: `${label}: ${counter.get(label)}` },
                        '*'
                    );
                    original_count(label);
                };

                window.console.countReset = (label = 'default') => {
                    if (counter.has(label)) {
                        counter.set(label, 0);
                    } else {
                        parent.postMessage(
                            {
                                type: 'console',
                                level: 'system-warn',
                                args: `Count for '${label}' does not exist`
                            },
                            '*'
                        );
                    }
                    original_countreset(label);
                };

                const original_trace = window.console.trace;

                window.console.trace = (...args) => {
                    const stack = new Error().stack;
                    parent.postMessage({ type: 'console', level: 'trace', args, stack }, '*');
                    original_trace(...args);
                };

                function stringify(args) {
                    try {
                        return JSON.stringify(args);
                    } catch (error) {
                        return null;
                    }
                }
            }

            function attachErrorListeners(frame) {
                frame.onerror = function (msg, url, lineNo, columnNo, error) {
                    parent.postMessage({ type: 'error', value: error }, '*');
                };

                frame.addEventListener('unhandledrejection', (event) => {
                    parent.postMessage({ type: 'unhandledrejection', value: event.reason }, '*');
                });
            }

            attachLogProxy(window)
            attachErrorListeners(window)

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/_sw_v1.js').then(async () => {
                    // console.log('Service Worker registered');
                    window.addEventListener('message', handleParentMessage)
                    window.parent.postMessage({type: "fetch-files"}, '*')

                }).catch(error => {
                    console.error('Service Worker registration failed:', error);
                });
            }

            window.beforeunload = async () => {
                if ('serviceWorker' in navigator) {
                    let registrations = await navigator.serviceWorker.getRegistrations();
                    
                    for (let registration of registrations) {
                        // console.log("Unregistered", registration);
                        registration.unregister();
                    }
                }
            };
        </script>
    </head>
    <body>
    </body>
</html>